#!/usr/bin/env nix-shell
#!nix-shell -i python -p python3 swiftPackages.swift-unwrapped nix pbzx cpio

"""
Generate a frameworks.nix for a macOS SDK.

You may point this tool at an Xcode bundled SDK, but more ideal is using the
SDK from Nixpkgs. For example:

SDK_PATH="$(nix-build --no-link -A darwin.apple_sdk_11_1.MacOSX-SDK)"
./gen-frameworks.py "$SDK_PATH" > ./new-frameworks.nix

Alternatively, you can use the apple-sdk-releases.json file generated by
`gen-apple-sdk-releases.py` to regenerate the public frameworks for each SDK:

./gen-frameworks.py --from-apple-sdk-releases ../apple-sdk-releases.json
"""

from pathlib import Path
import argparse
import json
import logging
import subprocess
import tempfile


logging.basicConfig(
    level=logging.DEBUG,
    datefmt="%Y-%m-%dT%H:%M:%S%z",
    format="[%(asctime)s][%(levelname)s] %(message)s",
)

logger = logging.getLogger(__name__)

ALLOWED_LIBS = ["simd"]

HEADER = """\
# This file is generated by gen-frameworks.nix.
# Do not edit, put overrides in apple_sdk.nix instead.
{ libs, frameworks }: with libs; with frameworks;
{
"""

FOOTER = """\
}
"""


def name_from_ident(ident):
    return ident.get("swift", ident.get("clang"))


def scan_sdk(sdk_dir: Path) -> str:
    """
    Generates a Nix attribute set for the given SDK.
    """
    # Find frameworks by scanning the SDK frameworks directory.
    frameworks = [
        framework
        for framework in map(
            lambda p: p.stem, (sdk_dir / "System/Library/Frameworks").iterdir()
        )
        if not framework.startswith("_")
    ]
    frameworks.sort()

    # Determine the longest name for padding output.
    width = len(max(frameworks, key=len))

    output = HEADER

    for framework in frameworks:
        deps = []

        # Use Swift to scan dependencies, because a module may have both Clang
        # and Swift parts. Using Clang only imports the Clang module, whereas
        # using Swift will usually import both Clang + Swift overlay.
        #
        # TODO: The above is an assumption. Not sure if it's possible a Swift
        # module completely shadows a Clang module. (Seems unlikely)
        #
        # TODO: Handle "module 'Foobar' is incompatible with feature 'swift'"
        #
        # If there were a similar Clang invocation for scanning, we could fix
        # the above todos, but that doesn't appear to exist.
        logger.info(f"Scanning {framework}")
        result = subprocess.run(
            [
                "swiftc",
                "-scan-dependencies",
                # We provide a source snippet via stdin.
                "-",
                # Use the provided SDK.
                "-sdk",
                sdk_dir.as_posix(),
                # This search path is normally added automatically by the
                # compiler based on the SDK, but we have a patch in place that
                # removes that for SDKs in /nix/store, because our xcbuild stub
                # SDK doesn't have the directory.
                # (swift-prevent-sdk-dirs-warning.patch)
                "-I",
                (sdk_dir / "usr/lib/swift").as_posix(),
                # For some reason, 'lib/swift/shims' from both the SDK and
                # Swift compiler are picked up, causing redefinition errors.
                # This eliminates the latter.
                "-resource-dir",
                (sdk_dir / "usr/lib/swift").as_posix(),
            ],
            input=f"import {framework}".encode(),
            stdout=subprocess.PIPE,
        )
        if result.returncode != 0:
            logger.error(f"Scanning {framework} failed (exit code {result.returncode})")
            result.stdout = b""

        # Parse JSON output.
        if len(result.stdout) != 0:
            data = json.loads(result.stdout)

            # Entries in the modules list come in pairs. The first is an
            # identifier (`{ swift: "foobar" }` or `{ clang: "foobar" }`), and
            # the second metadata for that module. Here we look for the pair
            # that matches the framework we're scanning (and ignore the rest).
            modules = data["modules"]
            for i in range(0, len(modules), 2):
                ident, meta = modules[i : i + 2]

                # NOTE: We may match twice, for a Swift module _and_ for a
                # Clang module. So matching here doesn't break from the loop,
                # and deps is appended to.
                if name_from_ident(ident) == framework:
                    dep_idents = meta["directDependencies"]
                    deps += [name_from_ident(ident) for ident in dep_idents]
                    # List unfiltered deps in progress output.
                    logger.info(f"{ident} -> {dep_idents}")

        # Filter out modules that are not separate derivations.
        # Also filter out duplicates (when a Swift overlay imports the Clang module)
        allowed = frameworks + ALLOWED_LIBS
        deps = set([dep for dep in deps if dep in allowed])

        # Filter out self-references. (Swift overlay importing Clang module.)
        if framework in deps:
            deps.remove(framework)

        # Generate a Nix attribute line.
        if len(deps) != 0:
            deps = list(deps)
            deps.sort()
            deps = " ".join(deps)
            output += f"  {framework.ljust(width)} = {{ inherit {deps}; }};\n"
        else:
            output += f"  {framework.ljust(width)} = {{}};\n"

    output += FOOTER
    return output


def extract_pkg_payload(path: Path) -> Path:
    """
    Returns the path to the Paylog extracted from the PKG file. This will be a temporary
    directory.
    """
    # Check if we already have the SDK extracted.
    logger.info("Checking if SDK is already extracted...")
    payload_dir = Path(tempfile.gettempdir()) / path.stem

    if payload_dir.exists():
        logger.info(f"Found extracted SDK at {payload_dir.as_posix()}")
        return payload_dir

    logger.info(
        "Payload has not been extracted yet, making temporary directory"
        f" {payload_dir.as_posix()}"
    )
    payload_dir.mkdir(parents=True)

    logger.info(
        f"Extracting Payload from {path.as_posix()} to {payload_dir.as_posix()}..."
    )
    # Run pbzx to extract the cpio archive from the PKG.
    pbzx = subprocess.run(
        ["pbzx", path.as_posix()],
        capture_output=True,
    )

    # Run cpio to extract the SDK from the cpio archive.
    cpio = subprocess.run(
        ["cpio", "-idm"],
        capture_output=True,
        input=pbzx.stdout,
        cwd=payload_dir,
    )

    # Ensure cpio succeeded.
    assert cpio.returncode == 0, f"cpio failed with exit code {cpio.returncode}"
    logger.info(f"Extracted Payload to {payload_dir.as_posix()}")

    return payload_dir


def find_sdk(payload_dir: Path) -> Path:
    """
    Returns the path to the SDK inside an extracted Payload directory.
    """
    sdk_dir = Path(payload_dir) / "Library/Developer/CommandLineTools/SDKs"
    sdks = [sdk for sdk in sdk_dir.iterdir() if not sdk.is_symlink()]
    assert len(sdks) == 1, f"Expected one SDK in {sdk_dir}, found {len(sdks)}: {sdks}"
    return sdks[0]


def nix_fetchurl(url: str, hash: str) -> Path:
    """
    Runs nix's fetchurl command to ensure the file is cached.
    """
    logger.info(f"Ensuring {url} is cached...")
    fetchurl_args = "{" + f'url = "{url}"; sha256 = "{hash}";' + "}"
    cache = subprocess.run(
        ["nix", "eval", "--raw", "--expr", f"builtins.fetchurl {fetchurl_args}"],
        capture_output=True,
    )
    assert cache.returncode == 0, (
        f"nix eval failed with exit code {cache.returncode}:"
        f" {cache.stderr.decode('utf-8')}"
    )
    store_path = Path(cache.stdout.decode("utf-8").strip())
    return store_path


def generate_frameworks_for_each_release(apple_sdk_releases: Path) -> None:
    """
    Generates a frameworks.nix for each SDK in the apple-sdk-releases.json at the given
    path.
    """
    releases = json.load(open(apple_sdk_releases, "r"))
    for version in releases:
        # Get the pkg for this version.
        fetchurl_args = releases[version]["CLTools_macOSNMOS_SDK"]

        # Ensure the pkg is cached.
        store_path = nix_fetchurl(**fetchurl_args)

        # Extract the SDK from the pkg.
        payload_dir = extract_pkg_payload(store_path)
        sdk_dir = find_sdk(payload_dir)

        # Create the directory for the version.
        frameworks_dir = Path(version)
        frameworks_dir.mkdir(parents=True, exist_ok=True)
        with open(frameworks_dir / "public.nix", "w") as f:
            f.write(scan_sdk(sdk_dir))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="gen-frameworks.py",
        description="Generate a frameworks.nix for a macOS SDK.",
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "--from-sdk",
        help="Use this SDK",
        type=str,
        required=False,
    )
    group.add_argument(
        "--from-pkg",
        help="Use the SDK from this PKG",
        type=str,
        required=False,
    )
    group.add_argument(
        "--from-apple-sdk-releases",
        help="Generate a framework.nix for each SDK in this apple-sdk-releases.json",
        type=str,
        required=False,
    )
    args = parser.parse_args()

    if args.from_apple_sdk_releases:
        generate_frameworks_for_each_release(args.from_apple_sdk_releases)
    elif args.from_pkg:
        payload_dir = extract_pkg_payload(args.from_pkg)
        sdk = find_sdk(payload_dir)
        print(scan_sdk(sdk))
    elif args.from_sdk:
        print(scan_sdk(args.from_sdk))
    else:
        parser.print_help()
